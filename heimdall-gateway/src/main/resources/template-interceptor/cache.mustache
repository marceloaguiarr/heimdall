import java.util.*;

import br.com.conductor.heimdall.core.enums.InterceptorLifeCycle;
import br.com.conductor.heimdall.core.util.BeanManager;
import br.com.conductor.heimdall.core.util.ConstantsCache;
import br.com.conductor.heimdall.core.util.UrlUtil;
import br.com.conductor.heimdall.gateway.filter.helper.HelperImpl;
import br.com.conductor.heimdall.gateway.filter.HeimdallFilter;
import br.com.conductor.heimdall.middleware.spec.ApiResponse;
import br.com.conductor.heimdall.middleware.spec.Helper;

import com.google.common.collect.Sets;
import com.netflix.zuul.context.RequestContext;

import java.nio.charset.StandardCharsets;

import org.redisson.api.RBucket;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;

import static br.com.conductor.heimdall.core.util.ConstantsCache.CACHE_BUCKET;
import static br.com.conductor.heimdall.core.util.ConstantsCache.CACHE_TIME_TO_LIVE;

import static org.springframework.cloud.netflix.zuul.filters.support.FilterConstants.PRE_TYPE;


public class CacheInterceptor extends HeimdallFilter {

    private static Set<String> pathsAllowed;

    private static Set<String> pathsNotAllowed;

    private static String inboundURL;

    private static String method;

    private static String cacheName;

    private static Long timeToLive;

    private Helper helper;

    public CacheInterceptor() {

        cacheName = "{{cache}}";

        timeToLive = {{timeToLive}};

        method = "{{method}}";

        pathsAllowed = Sets.newHashSet();
        {{#pathsAllowed}}
        pathsAllowed.add("{{.}}");
        {{/pathsAllowed}}

        pathsNotAllowed = Sets.newHashSet();
        {{#pathsNotAllowed}}
        pathsNotAllowed.add("{{.}}");
        {{/pathsNotAllowed}}

        inboundURL = "{{inboundURL}}";

        this.helper = new HelperImpl();
    }

    @Override
    public boolean should() {
        return InterceptorLifeCycle.{{lifeCycle}}.filter(pathsAllowed, pathsNotAllowed, inboundURL, method, RequestContext.getCurrentContext().getRequest());
    }

    @Override
    public void execute() throws Throwable {

        RedissonClient redisson = (RedissonClient) BeanManager.getBean(RedissonClient.class);

        RequestContext context = RequestContext.getCurrentContext();

        String apiId = (String) context.get("api-id");
        String apiName = (String) context.get("api-name");

        StringBuilder cacheKey = new StringBuilder();

        cacheKey
            .append(apiId)
            .append("-")
            .append(apiName)
            .append(":")
            .append(cacheName)
            .append("-")
            .append(UrlUtil.getCurrentUrl(context.getRequest()));

        RBucket<ApiResponse> rBucket = redisson.getBucket(cacheKey.toString());

        if (rBucket.get() == null) {
            context.put(CACHE_BUCKET, rBucket);
            context.put(CACHE_TIME_TO_LIVE, timeToLive);
        } else {
            ApiResponse response = rBucket.get();

            helper.call().response().header().addAll(response.getHeaders());
            helper.call().response().setBody(response.getBody());
            helper.call().response().setStatus(response.getStatus());
        }
    }

    @Override
    public String getName() {
        return "{{name}}";
    }

    @Override
    public String filterType() {
        return PRE_TYPE;
    }

    @Override
    public int filterOrder() {
        return {{order}};
    }
}
